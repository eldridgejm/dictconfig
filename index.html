

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dictconfig &mdash; dictconfig 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=01f34227"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            dictconfig
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">dictconfig</a></li>
<li><a class="reference internal" href="#demo">Demo</a></li>
<li><a class="reference internal" href="#quick-start">Quick Start</a><ul>
<li><a class="reference internal" href="#step-1-read-the-configuration-file-into-a-python-dictionary">Step 1: Read the configuration file into a Python dictionary</a></li>
<li><a class="reference internal" href="#step-2-define-a-schema">Step 2: Define a Schema</a></li>
<li><a class="reference internal" href="#step-3-resolve-the-configuration">Step 3: Resolve the configuration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#example-1-revisting-the-demo-with-external-variables">Example 1: Revisting the demo with external variables</a></li>
<li><a class="reference internal" href="#example-2-missing-required-keys">Example 2: Missing required keys</a></li>
<li><a class="reference internal" href="#example-3-schema-with-optional-keys-and-default-values">Example 3: Schema with optional keys and default values</a></li>
<li><a class="reference internal" href="#example-4-lists">Example 4: Lists</a></li>
<li><a class="reference internal" href="#example-5-nested-dictionaries">Example 5: Nested dictionaries</a></li>
<li><a class="reference internal" href="#example-6-using-jinja2-features-during-interpolation">Example 6: Using <cite>jinja2</cite> features during interpolation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#schemata">Schemata</a></li>
<li><a class="reference internal" href="#resolve"><code class="docutils literal notranslate"><span class="pre">resolve()</span></code></a><ul>
<li><a class="reference internal" href="#dictconfig.resolve"><code class="docutils literal notranslate"><span class="pre">resolve()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#parsers">Parsers</a><ul>
<li><a class="reference internal" href="#dictconfig.parsers.arithmetic"><code class="docutils literal notranslate"><span class="pre">arithmetic()</span></code></a></li>
<li><a class="reference internal" href="#dictconfig.parsers.logic"><code class="docutils literal notranslate"><span class="pre">logic()</span></code></a></li>
<li><a class="reference internal" href="#dictconfig.parsers.smartdate"><code class="docutils literal notranslate"><span class="pre">smartdate()</span></code></a></li>
<li><a class="reference internal" href="#dictconfig.parsers.smartdatetime"><code class="docutils literal notranslate"><span class="pre">smartdatetime()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">dictconfig</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">dictconfig</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="dictconfig">
<h1>dictconfig<a class="headerlink" href="#dictconfig" title="Link to this heading"></a></h1>
<p><cite>dictconfig</cite> is a Python library that makes it more convenient to use dictionaries
for program configuration.</p>
<p>The three main features of <cite>dictconfig</cite> are:</p>
<ul class="simple">
<li><p><strong>Validation</strong>: Dictionaries can be validated to ensure that required keys
are provided and their values have the right type, and missing optional
values are replaced with defaults.</p></li>
<li><p><strong>Interpolation</strong>: Configuration values can reference other parts of the
configuration, or even external variables supplied by the user. This allows
for configuration following the DRY (“Don’t Repeat Yourself”) principle.</p></li>
<li><p><strong>Calculations</strong>: Configuration values can be computed from expressions.
Built-in parsers are provided to do simple arithmetic on numbers and dates,
as well as logical operations on booleans. Custom parsers can be added to
handle other types.</p></li>
</ul>
</section>
<section id="demo">
<h1>Demo<a class="headerlink" href="#demo" title="Link to this heading"></a></h1>
<p>The following toy example demonstrates the core features of <cite>dictconfig</cite>. Consider
the YAML configuration file below:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">release-date</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">2025-01-10</span>
<span class="nt">due</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">7 days after ${this.release-date}</span>
<span class="nt">x</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">10</span>
<span class="nt">y</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">3</span>
<span class="nt">z</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">2 * ${this.x} + ${this.y}</span>
</pre></div>
</div>
<p>Notice that some of the fields in this configuration file contain references to
other fields and are calculated based on these references. For example, we’d
like the eventual value of <cite>due</cite> to be <code class="docutils literal notranslate"><span class="pre">2025-01-17</span></code> (i.e., 7 days after the
value of <code class="docutils literal notranslate"><span class="pre">release-date</span></code>).</p>
<p>Of course, if we read this YAML into a Python dictionary using any standard
YAML loader, the result will be the below dictionary, where the values of each
field are simply the literal values from the YAML file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s1">&#39;release-date&#39;</span><span class="p">:</span> <span class="s1">&#39;2025-01-10&#39;</span><span class="p">,</span>
    <span class="s1">&#39;due&#39;</span><span class="p">:</span> <span class="s1">&#39;7 days after ${this.release-date}&#39;</span><span class="p">,</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;2 * $</span><span class="si">{this.x}</span><span class="s1"> + $</span><span class="si">{this.y}</span><span class="s1">&#39;</span>
 <span class="p">}</span>
</pre></div>
</div>
<p><cite>dictconfig</cite> takes this dictionary as input and “resolves” references and calculated
values to obtain the following dictionary:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s1">&#39;release-date&#39;</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
    <span class="s1">&#39;due&#39;</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">17</span><span class="p">),</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">23</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="quick-start">
<h1>Quick Start<a class="headerlink" href="#quick-start" title="Link to this heading"></a></h1>
<p>There are three steps to reading a configuration file with <cite>dictconfig</cite>:</p>
<ol class="arabic simple">
<li><p>Read the configuration file into a Python dictionary (e.g., with PyYAML or the <code class="docutils literal notranslate"><span class="pre">json</span></code> module).</p></li>
<li><p>Define a schema for the configuration.</p></li>
<li><p>Call <a class="reference internal" href="#dictconfig.resolve" title="dictconfig.resolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictconfig.resolve()</span></code></a> to resolve the configuration.</p></li>
</ol>
<section id="step-1-read-the-configuration-file-into-a-python-dictionary">
<h2>Step 1: Read the configuration file into a Python dictionary<a class="headerlink" href="#step-1-read-the-configuration-file-into-a-python-dictionary" title="Link to this heading"></a></h2>
<p>If your program configuration is stored in a file (such as a YAML, JSON, or
TOML file), the first step is to read that configuration into a Python
dictionary. <cite>dictconfig</cite> is agnostic to the configration file format, and it
does not provide any file-reading functionality. Instead, you should use
third-party libraries like PyYAML, the <cite>json</cite> module, or the <cite>toml</cite> module to
read configuration files.</p>
<p>One note regarding YAML files: YAML parsers that stick to older versions of the
specification (somewhat infamously) try to guess user intent when parsing
strings. This leads to things like the “Norway problem” where Norway’s 2-letter
country code (“NO”) is parsed into the boolean <cite>False</cite>. Avoiding these issues
is actually quite simple: configure your YAML parser to read all values as
strings and let <cite>dictconfig</cite> handle the type conversion.</p>
</section>
<section id="step-2-define-a-schema">
<h2>Step 2: Define a Schema<a class="headerlink" href="#step-2-define-a-schema" title="Link to this heading"></a></h2>
<p>In order to validate a configuration and resolve its values, <cite>dictconfig</cite> needs
to know what keys to expect and the types of their values. This is done by
defining a schema. A schema is a Python dictionary that describes the expected
structure of the configuration.</p>
<p>A full description of the schema format can be found in the <a class="reference internal" href="#schemata">Schemata</a> section
below, however, a few simple examples are probably enough to help you get started.</p>
</section>
<section id="step-3-resolve-the-configuration">
<h2>Step 3: Resolve the configuration<a class="headerlink" href="#step-3-resolve-the-configuration" title="Link to this heading"></a></h2>
<p>Call <a class="reference internal" href="#dictconfig.resolve" title="dictconfig.resolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictconfig.resolve()</span></code></a> to resolve the configuration. This function
takes the configuration dictionary, the schema, and any external variables that
the configuration may reference. It returns the resolved configuration.</p>
</section>
</section>
<section id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Link to this heading"></a></h1>
<section id="example-1-revisting-the-demo-with-external-variables">
<h2>Example 1: Revisting the demo with external variables<a class="headerlink" href="#example-1-revisting-the-demo-with-external-variables" title="Link to this heading"></a></h2>
<p>This example extends the demo to show how external variables (variables that
aren’t defined in the configuration file, but which are provided and the time
of resolution) can be used in configuration values. The configuration file is
the same as before, but now we have an external variable <cite>today</cite> that is used
in the calculation of the <cite>tomorrow</cite> field:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">schema</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;dict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;required_keys&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;release_date&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span><span class="p">},</span>
        <span class="s2">&quot;due&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span><span class="p">},</span>
        <span class="s2">&quot;tomorrow&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span><span class="p">},</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">raw_configuration</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;release_date&#39;</span><span class="p">:</span> <span class="s1">&#39;2025-01-10&#39;</span><span class="p">,</span>
    <span class="s1">&#39;due&#39;</span><span class="p">:</span> <span class="s1">&#39;7 days after $</span><span class="si">{this.release_date}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tomorrow&#39;</span><span class="p">:</span> <span class="s1">&#39;1 day after $</span><span class="si">{today}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;2 * $</span><span class="si">{this.x}</span><span class="s1"> + $</span><span class="si">{this.y}</span><span class="s1">&#39;</span>
<span class="p">}</span>

<span class="n">resolved_configuration</span> <span class="o">=</span> <span class="n">dictconfig</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span>
    <span class="n">raw_configuration</span><span class="p">,</span>
    <span class="n">schema</span><span class="p">,</span>
    <span class="n">external_variables</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;today&quot;</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)}</span>
<span class="p">)</span>

<span class="n">pprint</span><span class="p">(</span><span class="n">resolved_configuration</span><span class="p">)</span>
</pre></div>
</div>
<p>The result is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{&#39;due&#39;: datetime.date(2025, 1, 17),
 &#39;release_date&#39;: datetime.date(2025, 1, 10),
 &#39;tomorrow&#39;: datetime.date(2025, 1, 8),
 &#39;x&#39;: 10,
 &#39;y&#39;: 3,
 &#39;z&#39;: 23}
</pre></div>
</div>
<p>A usecase of this feature is to allow configurations files to reference values
from <em>other</em> configuration files. This is done by reading the other
configuration files into dictionaries and passing them as external variables to
the <cite>resolve</cite> function.</p>
</section>
<section id="example-2-missing-required-keys">
<h2>Example 2: Missing required keys<a class="headerlink" href="#example-2-missing-required-keys" title="Link to this heading"></a></h2>
<p>Consider the example below, which is the same as the previous example, but where a
required key (“z”) is missing. <a class="reference internal" href="#dictconfig.resolve" title="dictconfig.resolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictconfig.resolve()</span></code></a> will catch this when it
does its validation and will raise a <code class="xref py py-class docutils literal notranslate"><span class="pre">dictconfig.exceptions.ResolutionError</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">schema</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;dict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;required_keys&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;release_date&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span><span class="p">},</span>
        <span class="s2">&quot;due&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span><span class="p">},</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">raw_configuration</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;release_date&#39;</span><span class="p">:</span> <span class="s1">&#39;2025-01-10&#39;</span><span class="p">,</span>
    <span class="s1">&#39;due&#39;</span><span class="p">:</span> <span class="s1">&#39;7 days after $</span><span class="si">{this.release_date}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">resolved_configuration</span> <span class="o">=</span> <span class="n">dictconfig</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">raw_configuration</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
<span class="k">except</span> <span class="n">dictconfig</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ResolutionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">pprint</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
</pre></div>
</div>
<p>The error message is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&#39;Cannot resolve keypath: &quot;z&quot;: Missing required key.&#39;
</pre></div>
</div>
</section>
<section id="example-3-schema-with-optional-keys-and-default-values">
<h2>Example 3: Schema with optional keys and default values<a class="headerlink" href="#example-3-schema-with-optional-keys-and-default-values" title="Link to this heading"></a></h2>
<p>Suppose some keys are not required and should have default values if they are
missing. In the example below, the key “x” is optional and has a default value
of 10:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">schema</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;dict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;required_keys&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
    <span class="p">},</span>
    <span class="s2">&quot;optional_keys&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">},</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">raw_configuration</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;2 * $</span><span class="si">{this.x}</span><span class="s1"> + $</span><span class="si">{this.y}</span><span class="s1">&#39;</span>
<span class="p">}</span>

<span class="n">resolved_configuration</span> <span class="o">=</span> <span class="n">dictconfig</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">raw_configuration</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">resolved_configuration</span><span class="p">)</span>
</pre></div>
</div>
<p>The result is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{&#39;x&#39;: 10, &#39;y&#39;: 3, &#39;z&#39;: 23}
</pre></div>
</div>
</section>
<section id="example-4-lists">
<h2>Example 4: Lists<a class="headerlink" href="#example-4-lists" title="Link to this heading"></a></h2>
<p>Despite its name, <cite>dictconfig</cite> can be used to validate and resolve more than
just dictionaries. The schema below describes a list of dictionaries, each dictionary
containing a string key <cite>name</cite> and an integer key <cite>age</cite>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">schema</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;list&quot;</span><span class="p">,</span>
    <span class="s2">&quot;element_schema&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;dict&quot;</span><span class="p">,</span>
        <span class="s2">&quot;required_keys&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">},</span>
            <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">raw_configuration</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">},</span>
    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">25</span><span class="p">},</span>
    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Charlie&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="mi">35</span><span class="p">},</span>
<span class="p">]</span>

<span class="n">resolved_configuration</span> <span class="o">=</span> <span class="n">dictconfig</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">raw_configuration</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">resolved_configuration</span><span class="p">)</span>
</pre></div>
</div>
<p>The result is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[{&#39;age&#39;: 30, &#39;name&#39;: &#39;Alice&#39;},
 {&#39;age&#39;: 25, &#39;name&#39;: &#39;Bob&#39;},
 {&#39;age&#39;: 35, &#39;name&#39;: &#39;Charlie&#39;}]
</pre></div>
</div>
</section>
<section id="example-5-nested-dictionaries">
<h2>Example 5: Nested dictionaries<a class="headerlink" href="#example-5-nested-dictionaries" title="Link to this heading"></a></h2>
<p>In the previous example, the <code class="docutils literal notranslate"><span class="pre">element_schema</span></code> key was used to describe the
schema for a list of dictionaries. A similar approach can be taken to write a
schema for nested dictionaries. The below example uses a schema describing a
dictionary with top-level keys “number” and “videos”, where the value of
“videos” is a list of dictionaries, each containing a string key <cite>title</cite> and an
integer key <cite>url</cite>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">schema</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;dict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;required_keys&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;videos&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;list&quot;</span><span class="p">,</span>
            <span class="s2">&quot;element_schema&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;dict&quot;</span><span class="p">,</span>
                <span class="s2">&quot;required_keys&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">},</span>
                    <span class="s2">&quot;url&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">raw_configuration</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s2">&quot;videos&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Video 1&quot;</span><span class="p">,</span> <span class="s2">&quot;url&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Video 2&quot;</span><span class="p">,</span> <span class="s2">&quot;url&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Video 3&quot;</span><span class="p">,</span> <span class="s2">&quot;url&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="p">]</span>
<span class="p">}</span>

<span class="n">resolved_configuration</span> <span class="o">=</span> <span class="n">dictconfig</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">raw_configuration</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">resolved_configuration</span><span class="p">)</span>
</pre></div>
</div>
<p>The result is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{&#39;number&#39;: 3,
 &#39;videos&#39;: [{&#39;title&#39;: &#39;Video 1&#39;, &#39;url&#39;: 1},
            {&#39;title&#39;: &#39;Video 2&#39;, &#39;url&#39;: 2},
            {&#39;title&#39;: &#39;Video 3&#39;, &#39;url&#39;: 3}]}
</pre></div>
</div>
</section>
<section id="example-6-using-jinja2-features-during-interpolation">
<h2>Example 6: Using <cite>jinja2</cite> features during interpolation<a class="headerlink" href="#example-6-using-jinja2-features-during-interpolation" title="Link to this heading"></a></h2>
<p><cite>dictconfig</cite> uses the <cite>jinja2</cite> templating engine for interpolation. This means
that you can use all the features of <cite>jinja2</cite> in your configuration files. For
example, <cite>jinja2</cite> allows for a kind of ternaly operator which can be used to
dynamically set the value of a key based on a condition.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">schema</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;dict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;required_keys&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">raw_configuration</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;${ this.x if this.x &gt; this.y else this.y }&#39;</span>
<span class="p">}</span>

<span class="n">resolved_configuration</span> <span class="o">=</span> <span class="n">dictconfig</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">raw_configuration</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">resolved_configuration</span><span class="p">)</span>
</pre></div>
</div>
<p>The result is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{&#39;x&#39;: 10, &#39;y&#39;: 3, &#39;z&#39;: 10}
</pre></div>
</div>
</section>
</section>
<section id="schemata">
<h1>Schemata<a class="headerlink" href="#schemata" title="Link to this heading"></a></h1>
<p>It is necessary to define a schema in order to specify the types of
configuration values. This section defines the formal grammar of a schema, but you
may be able to get a start by copying and modifying the examples above.</p>
<p>Before describing the grammar of a schema, it will be useful to reframe a
configuration dictionary as a tree.  For example, take the following dictionary
of options:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
     <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;My Book&#39;</span>
     <span class="n">release</span> <span class="o">=</span> <span class="p">{</span>
         <span class="n">date</span> <span class="o">=</span> <span class="s1">&#39;2021-10-10&#39;</span><span class="p">,</span>
         <span class="n">via</span> <span class="o">=</span> <span class="s1">&#39;email&#39;</span>
     <span class="p">},</span>
     <span class="n">authors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;me&#39;</span><span class="p">,</span> <span class="s1">&#39;you&#39;</span><span class="p">,</span> <span class="s1">&#39;everyone&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The root of the configuration tree is a dictionary with keys <cite>title</cite>,
<cite>release</cite>, and <cite>authors</cite>. This root has three children: first, the string <cite>“My
Book”</cite> corresponding to the <cite>title</cite> key. This child node is a leaf. The second
child is the dictionary corresponding to the <cite>release</cite> key; it is not a leaf
node. Instead, it is an <em>internal</em> dictionary node with two string-type leaf
nodes as children. The third child of the root is the list corresponding to the
authors; it is also not a leaf node. It is again an <em>internal</em> list node with
three string-type leaf nodes as children.</p>
<p>In general, internal nodes of the configuration tree are either dictionaries or
lists. Leaf nodes are non-container types, like strings, numbers, etc.</p>
<p>A <em>schema</em> defines the type of each of the nodes (internal and leaf) of the
configuration tree.  The “grammar” of a schema is roughly as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&lt;SCHEMA&gt; = (&lt;DICT_SCHEMA&gt; | &lt;LIST_SCHEMA&gt; | &lt;LEAF_SCHEMA&gt; | &lt;ANY_SCHEMA&gt;)

&lt;DICT_SCHEMA&gt; = {
    &quot;type&quot;: &quot;dict&quot;,
    [&quot;required_keys&quot;: {&lt;KEY_NAME&gt;: &lt;SCHEMA&gt;, ...}],
    [&quot;optional_keys&quot;: {&lt;KEY_NAME&gt;: (&lt;SCHEMA&gt; | &lt;SCHEMA_WITH_DEFAULT&gt;), ...}],
    [&quot;extra_keys_schema&quot;: &lt;SCHEMA&gt;],
    [&quot;nullable&quot;: (True | False)],
}

&lt;LIST_SCHEMA&gt; = {
    &quot;type&quot;: &quot;list&quot;,
    &quot;element_schema&quot;: &lt;SCHEMA&gt;,
    [&quot;nullable&quot;: (True | False)]
}

LEAF_SCHEMA = {
    &quot;type&quot;: (&quot;string&quot; | &quot;integer&quot; | &quot;float&quot; | &quot;boolean&quot; | &quot;date&quot; | &quot;datetime&quot;),
    [&quot;nullable&quot;: (True | False)]
}

&lt;ANY_SCHEMA&gt; = {
    &quot;type&quot;: &quot;any&quot;
}

&lt;SCHEMA_WITH_DEFAULT&gt; = (
    &lt;DICT_SCHEMA_WITH_DEFAULT&gt;
    | &lt;LIST_SCHEMA_WITH_DEFAULT&gt;
    | &lt;LEAF_SCHEMA_WITH_DEFAULT&gt;
    | &lt;ANY_SCHEMA_WITH_DEFAULT&gt;
)
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">&lt;SCHEMA_WITH_DEFAULT&gt;</span></code> is like its corresponding schema, but with an added
“default” key that supplies a default value.</p>
<p>A type of “any” denotes that the configuration option will be left as-is with
no parsing, however, interpolation still takes place.</p>
<p>Optionally, a leaf value can be “nullable”, meaning that <cite>None</cite> is a valid
type. By default, the leaf values are not nullable.</p>
</section>
<section id="resolve">
<h1><code class="docutils literal notranslate"><span class="pre">resolve()</span></code><a class="headerlink" href="#resolve" title="Link to this heading"></a></h1>
<p>Resolving a configuration is done via the <a class="reference internal" href="#dictconfig.resolve" title="dictconfig.resolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictconfig.resolve()</span></code></a> function:</p>
<dl class="py function">
<dt class="sig sig-object py" id="dictconfig.resolve">
<span class="sig-prename descclassname"><span class="pre">dictconfig.</span></span><span class="sig-name descname"><span class="pre">resolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw_cfg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">schema</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_variables=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override_parsers=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">schema_validator=&lt;function</span> <span class="pre">validate_schema&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_type=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dictconfig.resolve" title="Link to this definition"></a></dt>
<dd><p>Resolve a raw configuration by interpolating and parsing its entries.</p>
<p>The raw configuration can be a dictionary, list, or a non-container type;
resolution will be done recursively. In any case, the provided schema must
match the type of the raw configuration; for example, if the raw
configuration is a dictionary, the schema must be a dict schema.</p>
<p>Default parsers are provided which attempt to convert raw values to the
specified types. They are:</p>
<blockquote>
<div><ul class="simple">
<li><p>“integer”: <a class="reference internal" href="#dictconfig.parsers.arithmetic" title="dictconfig.parsers.arithmetic"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictconfig.parsers.arithmetic()</span></code></a> with type <cite>int</cite></p></li>
<li><p>“float”: <a class="reference internal" href="#dictconfig.parsers.arithmetic" title="dictconfig.parsers.arithmetic"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictconfig.parsers.arithmetic()</span></code></a> with type <cite>float</cite></p></li>
<li><p>“string”: n/a.</p></li>
<li><p>“boolean”: <a class="reference internal" href="#dictconfig.parsers.logic" title="dictconfig.parsers.logic"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictconfig.parsers.logic()</span></code></a></p></li>
<li><p>“date”: <a class="reference internal" href="#dictconfig.parsers.smartdate" title="dictconfig.parsers.smartdate"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictconfig.parsers.smartdate()</span></code></a></p></li>
<li><p>“datetime”: <a class="reference internal" href="#dictconfig.parsers.smartdatetime" title="dictconfig.parsers.smartdatetime"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictconfig.parsers.smartdatetime()</span></code></a></p></li>
</ul>
</div></blockquote>
<p>These parsers provide “smart” behavior, allowing values to be expressed in
a variety of formats. They can be overridden by providing a dictionary of
parsers to <cite>override_parsers</cite>.</p>
<p>A dictionary of external variables can be provided; these will be available
at interpolation time. A special key, <code class="docutils literal notranslate"><span class="pre">this</span></code>, is reserved and cannot
be used as an external variable. It refers to the root of the resolved
configuration.</p>
<p>This function uses the <cite>jinja2</cite> template engine for interpolation. This means
that many powerful <cite>Jinja2</cite> features can be used. For example, a <cite>Jinja2</cite> supports
a ternary operator, so dictionaries can contain expressions like the following:”</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;${ this.x if this.x &gt; this.y else this.y }&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Typically, <cite>raw_cfg</cite> will be a plain Python dictionary. Sometimes, however,
it may be another mapping type that behaves like a <cite>dict</cite>, but has some
additional functionality. One example is the <cite>ruamel</cite> package which is
capable of round-tripping yaml, comments and all. To accomplish this,
ruamel produces a dict-like object which stores the comments internally. If
we resolve this dict-like object with <code class="code docutils literal notranslate"><span class="pre">preserve_type</span> <span class="pre">=</span> <span class="pre">False</span></code>, then
we’ll lose these comments; therefore, we should use <code class="code docutils literal notranslate"><span class="pre">preserve_type</span> <span class="pre">=</span>
<span class="pre">True</span></code>.</p>
<p>At present, type preservation is done by constructing the resolved output
as normal, but then making a deep copy of <cite>raw_cfg</cite> and recursively copying
each leaf value into this deep copy. Therefore, there is a performance
cost.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw_cfg</strong> – The raw configuration.</p></li>
<li><p><strong>schema</strong> – The schema describing the types in the raw configuration.</p></li>
<li><p><strong>external_variables</strong> – A (nested) dictionary of external variables that may be interpolated into
the raw configuration. External variables can be referred to by dotted keypaths in
the configuration. For example, <code class="code docutils literal notranslate"><span class="pre">${foo.bar.baz}</span></code> will reference the value
42 in the dictionary <code class="code docutils literal notranslate"><span class="pre">{'foo':</span> <span class="pre">{'bar':</span> <span class="pre">{'baz':</span> <span class="pre">42}}}</span></code>. Cannot contain a key
named “this”.</p></li>
<li><p><strong>override_parsers</strong> – A dictionary mapping leaf type names to parser functions. The parser functions
should take the raw value (after interpolation) and convert it to the specified
type. If this is not provided, the default parsers are used.</p></li>
<li><p><strong>preserve_type</strong> (<em>bool</em><em> (</em><em>default: False</em><em>)</em>) – If False, the return value of this function is a plain dictionary. If this is
True, however, the return type will be the same as the type of raw_cfg. See
below for details.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>InvalidSchemaError</strong> – If the schema is not valid.</p></li>
<li><p><strong>ResolutionError</strong> – If the configuration does not match the schema, if there is a circular
    reference, or there is some other issue with the configuration itself.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<p>Resolving a leaf value in a configuration involves two steps: interpolation and
parsing.  In the easiest case, a leaf has no references to other fields or
external variables. In this case, the leaf’s raw value is passed through the
appropriate parser as determined by the schema in order to convert it to its
resolved value.</p>
<p>On the other hand, if the leaf value contains references to other fields or
external variables, these must be interpolated before parsing. If another
configuration field is referred to, it is first resolved recursively. The
resolved value of the field (or external variable) is then cast back into a
string and interpolated into the original leaf node’s value. Only then is the
parser applied to convert the leaf node’s string into the final resolved value.</p>
<p>In summary, the resolution of leaf nodes occurs via recursive string interpolation
followed by parsing into the final type.</p>
</section>
<section id="parsers">
<h1>Parsers<a class="headerlink" href="#parsers" title="Link to this heading"></a></h1>
<p>A parser is a function that accepts a raw value – often, but not necessarily a
string – and returns a resolved value with the appropriate type.</p>
<p>The default parsers are as follows:</p>
<ul class="simple">
<li><p>“integer”: The <a class="reference internal" href="#dictconfig.parsers.arithmetic" title="dictconfig.parsers.arithmetic"><code class="xref py py-func docutils literal notranslate"><span class="pre">arithmetic()</span></code></a> parser with type <cite>int</cite>.</p></li>
<li><p>“float”: The <a class="reference internal" href="#dictconfig.parsers.arithmetic" title="dictconfig.parsers.arithmetic"><code class="xref py py-func docutils literal notranslate"><span class="pre">arithmetic()</span></code></a> parser with type <cite>float</cite>.</p></li>
<li><p>“string”: No parser needed (left as string).</p></li>
<li><p>“boolean”: The <a class="reference internal" href="#dictconfig.parsers.logic" title="dictconfig.parsers.logic"><code class="xref py py-func docutils literal notranslate"><span class="pre">logic()</span></code></a> parser.</p></li>
<li><p>“date”: The <a class="reference internal" href="#dictconfig.parsers.smartdate" title="dictconfig.parsers.smartdate"><code class="xref py py-func docutils literal notranslate"><span class="pre">smartdate()</span></code></a> parser.</p></li>
<li><p>“datetime”: The <a class="reference internal" href="#dictconfig.parsers.smartdatetime" title="dictconfig.parsers.smartdatetime"><code class="xref py py-func docutils literal notranslate"><span class="pre">smartdatetime()</span></code></a> parser.</p></li>
</ul>
<p>Custom parsers can be added by defining a function that accepts a string and
returns the resolved value. The function should then be passed to the
<a class="reference internal" href="#dictconfig.resolve" title="dictconfig.resolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictconfig.resolve()</span></code></a> function in the <code class="docutils literal notranslate"><span class="pre">override_parsers</span></code> argument.</p>
<p>All available parsers in <code class="xref py py-mod docutils literal notranslate"><span class="pre">dictconfig.parsers</span></code> are shown below:</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dictconfig.parsers.arithmetic" title="dictconfig.parsers.arithmetic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arithmetic</span></code></a>(type_)</p></td>
<td><p>A factory that creates an arithmetic expression parser.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dictconfig.parsers.logic" title="dictconfig.parsers.logic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logic</span></code></a>(s)</p></td>
<td><p>Parses boolean logic expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dictconfig.parsers.smartdate" title="dictconfig.parsers.smartdate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smartdate</span></code></a>(s)</p></td>
<td><p>Parses natural language relative dates into date objects.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dictconfig.parsers.smartdatetime" title="dictconfig.parsers.smartdatetime"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smartdatetime</span></code></a>(s)</p></td>
<td><p>Parses natural language relative dates into datetime objects.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="dictconfig.parsers.arithmetic">
<span class="sig-prename descclassname"><span class="pre">dictconfig.parsers.</span></span><span class="sig-name descname"><span class="pre">arithmetic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dictconfig.parsers.arithmetic" title="Link to this definition"></a></dt>
<dd><p>A factory that creates an arithmetic expression parser.</p>
<p>The resulting function parses things like “(7 + 3) / 5” into the specified
numeric type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>type</strong> – The end type that the resulting value should be converted to.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">dictconfig.parsers</span><span class="w"> </span><span class="kn">import</span> <span class="n">arithmetic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">arithmetic</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="p">(</span><span class="s1">&#39;(7 + 3) / 5&#39;</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">42</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dictconfig.parsers.logic">
<span class="sig-prename descclassname"><span class="pre">dictconfig.parsers.</span></span><span class="sig-name descname"><span class="pre">logic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dictconfig.parsers.logic" title="Link to this definition"></a></dt>
<dd><p>Parses boolean logic expressions.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">dictconfig.parsers</span><span class="w"> </span><span class="kn">import</span> <span class="n">logic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logic</span><span class="p">(</span><span class="s1">&#39;True and (False or True)&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dictconfig.parsers.smartdate">
<span class="sig-prename descclassname"><span class="pre">dictconfig.parsers.</span></span><span class="sig-name descname"><span class="pre">smartdate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dictconfig.parsers.smartdate" title="Link to this definition"></a></dt>
<dd><p>Parses natural language relative dates into date objects.</p>
<p>Input strings can be in one of three forms:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Dates in ISO format, e.g.: “2021-10-01”.</p></li>
<li><p>Relative dates of the form <code class="code docutils literal notranslate"><span class="pre">&quot;&lt;n&gt;</span> <span class="pre">day(s)</span> <span class="pre">(before|after)</span> <span class="pre">&lt;ISO</span> <span class="pre">date&gt;&quot;</span></code>,
e.g., “3 days before 2021-10-10”</p></li>
<li><p>Relative dates of the form <code class="code docutils literal notranslate"><span class="pre">&quot;first</span>
<span class="pre">&lt;day_of_week&gt;[,&lt;day_of_week&gt;,...,&lt;day_of_week&gt;]</span> <span class="pre">(before|after)</span> <span class="pre">&lt;ISO</span> <span class="pre">date&gt;&quot;</span></code>,
e.g., “first monday, wednesday after 2021-10-10”</p></li>
</ol>
</div></blockquote>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">dictconfig.parsers</span><span class="w"> </span><span class="kn">import</span> <span class="n">smartdate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smartdate</span><span class="p">(</span><span class="s1">&#39;2021-10-01&#39;</span><span class="p">)</span>
<span class="go">datetime.date(2021, 10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smartdate</span><span class="p">(</span><span class="s1">&#39;1 day after 2021-10-01&#39;</span><span class="p">)</span>
<span class="go">datetime.date(2021, 10, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smartdate</span><span class="p">(</span><span class="s1">&#39;3 days before 2021-10-05&#39;</span><span class="p">)</span>
<span class="go">datetime.date(2021, 10, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smartdate</span><span class="p">(</span><span class="s1">&#39;first monday after 2021-09-10&#39;</span><span class="p">)</span>
<span class="go">datetime.date(2021, 9, 13)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dictconfig.parsers.smartdatetime">
<span class="sig-prename descclassname"><span class="pre">dictconfig.parsers.</span></span><span class="sig-name descname"><span class="pre">smartdatetime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dictconfig.parsers.smartdatetime" title="Link to this definition"></a></dt>
<dd><p>Parses natural language relative dates into datetime objects.</p>
<p>The forms of the input are the same as for <a class="reference internal" href="#dictconfig.parsers.smartdate" title="dictconfig.parsers.smartdate"><code class="xref py py-func docutils literal notranslate"><span class="pre">smartdate()</span></code></a>, except ISO times
are permitted. For instance: <code class="code docutils literal notranslate"><span class="pre">3</span> <span class="pre">days</span> <span class="pre">after</span> <span class="pre">2021-10-05</span> <span class="pre">23:59:00</span></code>.</p>
</dd></dl>

</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Link to this heading"></a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Justin Eldridge.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>