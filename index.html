<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Welcome to dictconfig’s documentation! &mdash; dictconfig 0.1.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="#" class="icon icon-home"> dictconfig
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Welcome to dictconfig’s documentation!</a><ul>
<li><a class="reference internal" href="#quick-start">Quick Start</a></li>
<li><a class="reference internal" href="#usage">Usage</a><ul>
<li><a class="reference internal" href="#schemata">Schemata</a></li>
<li><a class="reference internal" href="#resolving-configurations">Resolving Configurations</a></li>
<li><a class="reference internal" href="#parsers">Parsers</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">dictconfig</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
      <li>Welcome to dictconfig’s documentation!</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="welcome-to-dictconfig-s-documentation">
<h1>Welcome to dictconfig’s documentation!<a class="headerlink" href="#welcome-to-dictconfig-s-documentation" title="Permalink to this headline"></a></h1>
<div class="toctree-wrapper compound">
</div>
<p>A straightforward way of configuring a piece of Python software is to read
configuration settings from a file (usually JSON or YAML) into a Python
dictionary. While this is convenient, this approach has some limitations;
namely, fields within a JSON or YAML file cannot make use of variables, nor can
they reference one another.</p>
<p><cite>dictconfig</cite> is a Python package that aims to ease these limitations by
supporting:</p>
<ol class="arabic simple">
<li><p><strong>External Variables</strong>: Configuration values can reference external
variables supplied by the program reading the configuration.</p></li>
<li><p><strong>Internal References</strong>: The configuration can reference other settings
within the same configuration.</p></li>
<li><p><strong>Domain-specific languages</strong>: Custom parsers can be provided to convert
configuration options to Python types in a domain-specific way. <cite>dateconfig</cite>
comes with parsers for interpreting arithmetic expressions (e.g., <cite>“(4 + 6) / 2”</cite>),
logical expressions (e.g., <cite>“True and (False or True)”</cite>), and relative datetimes
(e.g., <cite>“7 days after 2021-10-10”</cite>).</p></li>
</ol>
<section id="quick-start">
<h2>Quick Start<a class="headerlink" href="#quick-start" title="Permalink to this headline"></a></h2>
<p>Below is an example of what <cite>dictconfig</cite> offers. Suppose we have a YAML file
containing:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">x</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">10</span>
<span class="nt">y</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">32</span>
<span class="nt">z</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">${self.x} + ${self.y}</span>
<span class="nt">released</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">${foo.bar}</span>
<span class="nt">due</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">${self.x} days after ${self.released}</span>
</pre></div>
</div>
<p>Intuitively, we want the value of <cite>z</cite> to be the sum of <cite>x</cite> and <cite>y</cite> (i.e., 42).
In this example, <code class="code docutils literal notranslate"><span class="pre">${foo.bar}</span></code> refers to an “external variable”
provided by the software that reads the config.  Apparently, we want the value
of <cite>due</cite> to resolve to ten days after this release date.</p>
<p>However, if we read this YAML into a Python dictionary <code class="code docutils literal notranslate"><span class="pre">dct</span></code> using any
standard YAML loader, the value of <cite>z</cite> will simply be the string above; it will
<em>not</em> be the number 42. Likewise, the value of the <cite>released</cite> and <cite>due</cite> fields
will not be as desired.</p>
<p>With <cite>dictconfig</cite>’s interpolation and reference features, however, we can resolve
the configuration above into what we expect. First, we must specify a <em>schema</em>.
A <em>schema</em> is a Python dictionary that tells <cite>dictconfig</cite> what types to expect
for each configuration option. Here is a schema for this configuration file
that says that the keys <cite>x</cite>, <cite>y</cite>, and <cite>z</cite> are all integers and that <cite>released</cite>
and <cite>due</cite> are dates:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">schema</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;dict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;schema&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">},</span>
        <span class="s2">&quot;released&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span><span class="p">},</span>
        <span class="s2">&quot;due&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span><span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As can be seen from above, a schema is a nested dictionary describing the expected
types of configuration values. For a more precise definition of a schema, see the
<a class="reference internal" href="#schemata">Schemata</a> section below.</p>
<p>Next, we call <code class="code docutils literal notranslate"><span class="pre">dictconfig.resolve()</span></code> to <em>resolve</em> the configuration. We provide
a dictionary of external variables that can be resolved.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dictconfig</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">external_variables</span> <span class="o">=</span> <span class="p">{</span>
<span class="go">    &#39;foo&#39;: {&#39;bar&#39;: &#39;2021-10-01&#39;, &#39;baz&#39;: None},</span>
<span class="go">    &#39;bar&#39;: 42</span>
<span class="go">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dictconfig</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">external_variables</span><span class="o">=</span><span class="n">external_variables</span><span class="p">)</span>
<span class="go">{</span>
<span class="go">    &quot;x&quot;: 10,</span>
<span class="go">    &quot;y&quot;: 32,</span>
<span class="go">    &quot;z&quot;: 42,</span>
<span class="go">    &quot;released&quot;: datetime.date(2021, 10, 1),</span>
<span class="go">    &quot;due&quot;: datetime.date(2021, 10, 11),</span>
<span class="go">}</span>
</pre></div>
</div>
<p>During resolution, the values of <cite>x</cite> and <cite>y</cite> are looked up and interpolated
into the definition of <cite>z</cite>, resulting in the string <cite>10 + 32</cite>. The schema tells
<cite>dictconfig</cite> that the result should be an integer, so an attempt is made to
convert this string to an <cite>int</cite>. The default string-to-int parser in
<cite>dictconfig</cite> is capable of evaluating basic arithmetic expressions, and
therefore produces the value of 42.</p>
<p>Likewise, the reference to <code class="code docutils literal notranslate"><span class="pre">${foo.bar}</span></code> is resolved from the external variables
and converted to a date as per the schema. The <cite>due</cite> field is resolved by referring to
the <cite>released</cite> field. The default date parser is smart enough to handle
relative dates written as above. See the <a class="reference internal" href="#parsers">Parsers</a> section below for more
information on the parsers.</p>
</section>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline"></a></h2>
<p>This section describes the usage of the package in greater detail, starting
with the creation of schemata.</p>
<section id="schemata">
<h3>Schemata<a class="headerlink" href="#schemata" title="Permalink to this headline"></a></h3>
<p>It is necessary to define a schema in order to specify the types of
configuration values.  But before describing the grammar of a schema, it will
be useful to reconceptualize the configuration as a tree.  For example, take
the following dictionary of options:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
     <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;My Book&#39;</span>
     <span class="n">release</span> <span class="o">=</span> <span class="p">{</span>
         <span class="n">date</span> <span class="o">=</span> <span class="s1">&#39;2021-10-10&#39;</span><span class="p">,</span>
         <span class="n">via</span> <span class="o">=</span> <span class="s1">&#39;email&#39;</span>
     <span class="p">},</span>
     <span class="n">authors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;me&#39;</span><span class="p">,</span> <span class="s1">&#39;you&#39;</span><span class="p">,</span> <span class="s1">&#39;everyone&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The root of the configuration tree is a dictionary with keys <cite>title</cite>,
<cite>release</cite>, and <cite>authors</cite>. This root has three children: first, the string <cite>“My
Book”</cite> corresponding to the <cite>title</cite> key. This child node is a leaf. The second
child is the dictionary corresponding to the <cite>release</cite> key; it is not a leaf
node. Instead, it is an <em>internal</em> dictionary node with two string-type leaf
nodes as children. The third child of the root is the list corresponding to the
authors; it is also not a leaf node. It is again an <em>internal</em> list node with
three string-type leaf nodes as children.</p>
<p>In general, internal nodes of the configuration tree are either dictionaries or
lists. Leaf nodes are non-container types, like strings, numbers, etc.</p>
<p>A <em>schema</em> defines the type of each of the nodes (internal and leaf) of the
configuration tree.  The “grammar” of a schema is roughly as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&lt;SCHEMA&gt; = (&lt;DICT_SCHEMA&gt; | &lt;LIST_SCHEMA&gt; | &lt;LEAF_SCHEMA&gt;)

&lt;DICT_SCHEMA&gt; = {
    type: &quot;dict&quot;,
    schema = {
        key_1: &lt;SCHEMA&gt;,
        [key_2: &lt;SCHEMA&gt;,]
        [key_3: &lt;SCHEMA&gt;,]
    }
}

&lt;LIST_SCHEMA&gt; = {
    type: &quot;list&quot;,
    schema: &lt;SCHEMA&gt;
}

&lt;LEAF_SCHEMA&gt; = {
    type: (&quot;string&quot; | &quot;integer&quot; | &quot;float&quot; | &quot;boolean&quot; | &quot;datetime&quot; ),
    [nullable: (True|False)]
}
</pre></div>
</div>
<p>Optionally, a leaf value can be “nullable”, meaning that <cite>None</cite> is a valid type. By default,
the leaf values are not nullable.</p>
<p>This grammar is a subset of that defined by the <a class="reference external" href="https://docs.python-cerberus.org/en/stable/">Cerberus</a> dict validator.
Therefore, <cite>dictconfig</cite> schemas can be parsed by Cerberus.</p>
<p>Here is an example of a valid schema for the configuration dictionary from
the start of this section:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{
    &#39;type&#39;: &#39;dict&#39;,
    &#39;schema&#39;: {
        &#39;title&#39;: {&#39;type&#39;: &#39;string&#39;},
        &#39;release&#39;: {
            &#39;type&#39;: &#39;dict&#39;,
            &#39;schema&#39;: {
                &#39;date&#39;: &#39;date&#39;,
                &#39;via&#39;: &#39;string&#39;
            }
        },
        &#39;authors&#39;: {
            &#39;type&#39;: &#39;list&#39;,
            &#39;schema&#39;: {&#39;type&#39;: &#39;string&#39;}
        }
    }
}
</pre></div>
</div>
</section>
<section id="resolving-configurations">
<h3>Resolving Configurations<a class="headerlink" href="#resolving-configurations" title="Permalink to this headline"></a></h3>
<p>Resolving a configuration is done via the <a class="reference internal" href="#dictconfig.resolve" title="dictconfig.resolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictconfig.resolve()</span></code></a> function:</p>
<dl class="py function">
<dt class="sig sig-object py" id="dictconfig.resolve">
<span class="sig-prename descclassname"><span class="pre">dictconfig.</span></span><span class="sig-name descname"><span class="pre">resolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw_cfg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">schema</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override_parsers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dictconfig.resolve" title="Permalink to this definition"></a></dt>
<dd><p>Resolve a raw configuration by interpolating and parsing its entries.</p>
<p>The raw configuration can be a dictionary, list, or a non-container type;
resolution will be done recursively. In any case, the provided schema must
match the type of the raw configuration; for example, if the raw
configuration is a dictionary, the schema must be a dict schema.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw_cfg</strong> – The raw configuration.</p></li>
<li><p><strong>schema</strong> – The schema describing the types in the raw configuration.</p></li>
<li><p><strong>external_variables</strong> – A (nested) dictionary of external variables that may be interpolated into
the raw configuration. External variables can be referred to by dotted paths in
the configuration. For example, <code class="code docutils literal notranslate"><span class="pre">${foo.bar.baz}</span></code> will reference the value
42 in the dictionary <code class="code docutils literal notranslate"><span class="pre">{'foo':</span> <span class="pre">{'bar':</span> <span class="pre">{'baz':</span> <span class="pre">42}}}</span></code>.</p></li>
<li><p><strong>override_parsers</strong> – A dictionary mapping leaf type names to parser functions. The parser functions
should take the raw value (after interpolation) and convert it to the specified
type. If this is not provided, the default parsers are used.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<p>Resolving a leaf value in a configuration involves two steps: interpolation and
parsing.  In the easiest case, a leaf has no references to other fields or
external variables. In this case, the leaf’s raw value is passed through the
appropriate parser as determined by the schema in order to convert it to its
resolved value.</p>
<p>On the other hand, if the leaf value contains references to other fields or
external variables, these must be interpolated before parsing. If another
configuration field is referred to, it is first resolved recursively. The
resolved value of the field (or external variable) is then cast back into a
string and interpolated into the original leaf node’s value. Only then is the
parser applied to convert the leaf node’s string into the final resolved value.</p>
<p>In summary, the resolution of leaf nodes occurs via recursive string interpolation
followed by parsing into the final type.</p>
</section>
<section id="parsers">
<h3>Parsers<a class="headerlink" href="#parsers" title="Permalink to this headline"></a></h3>
<p>A parser is a function that accepts a raw value – often, but not necessarily a
string – and returns a resolved value with the appropriate type.</p>
<p>The default parsers are as follows:</p>
<ul class="simple">
<li><p>“integer”: The <a class="reference internal" href="#dictconfig.parsers.arithmetic" title="dictconfig.parsers.arithmetic"><code class="xref py py-func docutils literal notranslate"><span class="pre">arithmetic()</span></code></a> parser with type <cite>int</cite>.</p></li>
<li><p>“float”: The <a class="reference internal" href="#dictconfig.parsers.arithmetic" title="dictconfig.parsers.arithmetic"><code class="xref py py-func docutils literal notranslate"><span class="pre">arithmetic()</span></code></a> parser with type <cite>float</cite>.</p></li>
<li><p>“string”: No parser needed (left as string).</p></li>
<li><p>“boolean”: The <a class="reference internal" href="#dictconfig.parsers.logic" title="dictconfig.parsers.logic"><code class="xref py py-func docutils literal notranslate"><span class="pre">logic()</span></code></a> parser.</p></li>
<li><p>“date”: The <a class="reference internal" href="#dictconfig.parsers.smartdate" title="dictconfig.parsers.smartdate"><code class="xref py py-func docutils literal notranslate"><span class="pre">smartdate()</span></code></a> parser.</p></li>
<li><p>“datetime”: The <a class="reference internal" href="#dictconfig.parsers.smartdatetime" title="dictconfig.parsers.smartdatetime"><code class="xref py py-func docutils literal notranslate"><span class="pre">smartdatetime()</span></code></a> parser.</p></li>
</ul>
<p>All available parsers in <code class="xref py py-mod docutils literal notranslate"><span class="pre">dictconfig.parsers</span></code> are shown below:</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dictconfig.parsers.arithmetic" title="dictconfig.parsers.arithmetic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arithmetic</span></code></a>(type_)</p></td>
<td><p>A factory that creates an arithmetic expression parser.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dictconfig.parsers.logic" title="dictconfig.parsers.logic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logic</span></code></a>(s)</p></td>
<td><p>Parses boolean logic expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dictconfig.parsers.smartdate" title="dictconfig.parsers.smartdate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smartdate</span></code></a>(s)</p></td>
<td><p>Parses natural language relative dates into date objects.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dictconfig.parsers.smartdatetime" title="dictconfig.parsers.smartdatetime"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smartdatetime</span></code></a>(s)</p></td>
<td><p>Parses natural language relative dates into datetime objects.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="dictconfig.parsers.arithmetic">
<span class="sig-prename descclassname"><span class="pre">dictconfig.parsers.</span></span><span class="sig-name descname"><span class="pre">arithmetic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dictconfig.parsers.arithmetic" title="Permalink to this definition"></a></dt>
<dd><p>A factory that creates an arithmetic expression parser.</p>
<p>The resulting function parses things like “(7 + 3) / 5” into the specified
numeric type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>type</strong> – The end type that the resulting value should be converted to.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">arithmetic</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="p">(</span><span class="s1">&#39;(7 + 3) / 5&#39;</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">42</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dictconfig.parsers.logic">
<span class="sig-prename descclassname"><span class="pre">dictconfig.parsers.</span></span><span class="sig-name descname"><span class="pre">logic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dictconfig.parsers.logic" title="Permalink to this definition"></a></dt>
<dd><p>Parses boolean logic expressions.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">logic</span><span class="p">(</span><span class="s1">&#39;True and (False or True)&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dictconfig.parsers.smartdate">
<span class="sig-prename descclassname"><span class="pre">dictconfig.parsers.</span></span><span class="sig-name descname"><span class="pre">smartdate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dictconfig.parsers.smartdate" title="Permalink to this definition"></a></dt>
<dd><p>Parses natural language relative dates into date objects.</p>
<p>Input strings can be in one of three forms:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Dates in ISO format, e.g.: “2021-10-1”.</p></li>
<li><p>Relative dates of the form <code class="code docutils literal notranslate"><span class="pre">&quot;&lt;n&gt;</span> <span class="pre">days</span> <span class="pre">(before|after)</span> <span class="pre">&lt;ISO</span> <span class="pre">date&gt;&quot;</span></code>,
e.g., “3 days before 2021-10-10”</p></li>
<li><p>Relative dates of the form <code class="code docutils literal notranslate"><span class="pre">&quot;first</span>
<span class="pre">&lt;day_of_week&gt;[,&lt;day_of_week&gt;,...,&lt;day_of_week&gt;]</span> <span class="pre">(before|after)</span> <span class="pre">&lt;ISO</span> <span class="pre">date&gt;&quot;</span></code>,
e.g., “first monday, wednesday after 2021-10-10”</p></li>
</ol>
</div></blockquote>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">smartdate</span><span class="p">(</span><span class="s1">&#39;2021-10-1&#39;</span><span class="p">)</span>
<span class="go">datetime.date(2021, 10, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smartdate</span><span class="p">(</span><span class="s1">&#39;3 days after 2021-10-1&#39;</span><span class="p">)</span>
<span class="go">datetime.date(2021, 10, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smartdate</span><span class="p">(</span><span class="s1">&#39;3 days before 2021-10-5&#39;</span><span class="p">)</span>
<span class="go">datetime.date(2021, 10, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smartdate</span><span class="p">(</span><span class="s1">&#39;first monday after 2021-09-10&#39;</span><span class="p">)</span>
<span class="go">datetime.date(2021, 9, 13)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dictconfig.parsers.smartdatetime">
<span class="sig-prename descclassname"><span class="pre">dictconfig.parsers.</span></span><span class="sig-name descname"><span class="pre">smartdatetime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dictconfig.parsers.smartdatetime" title="Permalink to this definition"></a></dt>
<dd><p>Parses natural language relative dates into datetime objects.</p>
<p>The forms of the input are the same as for <a class="reference internal" href="#dictconfig.parsers.smartdate" title="dictconfig.parsers.smartdate"><code class="xref py py-func docutils literal notranslate"><span class="pre">smartdate()</span></code></a>, except ISO times
are permitted. For instance: <code class="code docutils literal notranslate"><span class="pre">3</span> <span class="pre">days</span> <span class="pre">after</span> <span class="pre">2021-10-05</span> <span class="pre">23:59:00</span></code>.</p>
</dd></dl>

</section>
</section>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline"></a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Justin Eldridge.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>